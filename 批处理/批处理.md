[TOC]

# 常用DOS命令

## 系统命令

```shell
convert <disk:> /fs:ntfs                 # 无损转换文件系统
nslookup                                 # 查询dns映射
```

### ping

```shell
ping <target>                            # 测试网络联通
----------------------------------------------------------------
    -n count                             # 要发送的回显请求数。
    -w timeout                           # 等待每次回复的超时时间(毫秒)。
    -s srcaddr                           # 要使用的源地址。
----------------------------------------------------------------
# ping本机11次，可用于批处理延时10秒。命令中的>nul为屏蔽输出。
ping -n 11 127.0.0.1 >nul
```

### ipconfig

```shell
ipconfig                                 # 查看ip信息
----------------------------------------------------------------
    /all                                 # 查看完整的ip信息
    /displaydns                          # 查看dns缓存
    /flushdns                            # 清除dns缓存
```

### arp

```shell
arp -a [ip]                              # 查看arp缓存表，缺省值ip显示所有arp项
arp -g [ip]                              # 同 -a
arp -s <ip> <mac>                        # 添加静态arp
arp -d [ip]                              # 删除静态arp，缺省值ip删除所有arp项
```

### start

```shell
start [/min | /max] “title” <file>      # 启动命令
# title可以省略，filename如带有空格或是特殊符号的，用""括起来。
----------------------------------------------------------------
    /min                                # 使开启的窗口最小化
    /max                                # 使开启的窗口最大化
----------------------------------------------------------------
start http://www.baidu.com
# 打开百度
----------------------------------------------------------------
start "" "%windir%\system32\NOTEPAD.EXE" "%userprofile%\桌面\abc.txt"
# 用NOTEPAD（记事本）打开桌面上的abc.txt。
----------------------------------------------------------------
start "" "%userprofile%\桌面\abc.doc"
# 这里start后面要加""才能启动文件abc.doc
# 如果start后没有""则表示把title省略了
# 此时文件名若有""的话start就会把它看作是标题，从而变成了省略文件名，就默认开启cmd了
# 所以在start后加上""就能防止这种意外的情况。
----------------------------------------------------------------
start /min "" "%windir%\system32\NOTEPAD.EXE" "%userprofile%\桌面\abc.txt"
# 用记事本最小化打开桌面的abc.txt。
```

### taskkill

- Taskkill命令可以根据进程ID或图像名来结束一个或多个任务或进程。

```shell
taskkill /im <ImageName>           # 指定将终止的进程的图像名称。
    /f <process>                   # 指定将强制终止的进程。
                                   # 对于远程进程可忽略此参数，所有远程进程都将被强制终止。
    /pid process-id                # 指定要终止的进程的PID
----------------------------------------------------------------
# 例：
taskkill /im qq.exe
taskkill /f /im spoolsv.exe
taskkill /pid 1230 /pid 1241 /pid 1253
# 终止PID 分别为 1230 1241 1253的进程
```

### shutdown

```shell
shutdown [/i | /l | /s | /r | /a | /h | /e | /o] [/f]
         [/m \\computer][/t xxx][/d [p|u:]xx:yy [/c "comment"]]
----------------------------------------------------------------
    /i         显示图形用户界面(GUI),必须是第一个选项。
    /l         注销。这不能与 /m 或 /d 选项一起使用。
    /s         关闭计算机。
    /r         完全关闭并重启计算机。
    /a         中止系统关闭，这只能在超时期间使用。
    /h         休眠本地计算机，可以与 /f 选项一起使用。
    /e         记录计算机意外关闭的原因。
    /o         转到高级启动选项菜单并重新启动计算机。
               必须与 /r 选项一起使用。
    /m \\computer 指定目标计算机。
    /t xxx     将关闭前的超时时间设置为 xxx 秒。
               有效范围是 0-315360000 (10 年)，默认值为 30。
    /c "comment" 注释重启或关闭的原因，最多允许 512 个字符。
    /f         强制关闭正在运行的应用程序而不事先警告用户。
    /d [p|u:]xx:yy  提供重新启动或关闭的原因。
               p 指示重启或关闭是计划内的。
               u 指示原因是用户定义的。
               如果未指定 p 和 u，则重新启动或关闭是计划外的。
               xx 是主要原因编号(小于 256 的正整数)。
               yy 是次要原因编号(小于 65536 的正整数)。
----------------------------------------------------------------
shutdown -l
# 该命令只能注销本机用户，对远程计算机不适用。
----------------------------------------------------------------
at 12:00 shutdown -s
# 通过-s参数，在12：00执行关闭计算机。
----------------------------------------------------------------
shutdown -r -t 60
# 60秒后重启计算机。如果没有设置时间则默认为30秒。
----------------------------------------------------------------
shutdown -f -s -t 300
# 通过-f参数强制计算机300秒后关闭。
----------------------------------------------------------------
shutdown -a
# 当我们在遇到冲击波或震荡波病毒时，或是执行了上面的关机命令时
# 我们可以运用shutdown -a 终止当前的关机进程，这样就可以避免关机而造成的损失了。
```

## 基本命令

### 回显：echo、@

```shell
echo                                     # 显示当前echo命令状态（off或on）
echo [{ on|off }]                        # 打开或关闭回显
@<command>                               # 关闭显示改行命令本身
----------------------------------------------------------------
echo <balabala...>  echo [{ on|off }]    # 显示一段信息
echo.                                    # 输出空行，“.”可以用，：；”／]＋\任一符号替代
echo <content> > <filenema>              # 建立新文件或增加文件内容
echo <reply>|<command>                   # 答复命令中的提问
----------------------------------------------------------------
# 例：用rd 命令删除时它将会询问你Y或N，利用echo可自动帮我们输入Y确认
@echo off
echo Y|rd /s c:\abc
pause
```

### 注释：rem

```shell
rem <balabala...>                         # 注释命令，该命令后的内容不被执行，但能回显
:: <balabala...>                          # 注释命令，该命令后的内容不被执行，也不能回显
```

- 任何以冒号：开头的字符行,在批处理中都被视作标号, 而直接忽略其后的所有内容。
- 有效标号：冒号后紧跟一个以字母数字开头的字符串，goto 语句可以识别。
- 无效标号：冒号后紧跟一个非字母数字的一个特殊符号，goto 无法识别的标号，可以起到注释
  作用，所以 :: 常被用作注释符号，其实 : 也可起注释作用。

### 目录切换：cd

```shell
cd <path>                       # 切换到目标路径
cd..                            # 返回上级目录
cd\                             # 切换到根目录
cd                              # 显示当前的完整路径，一般用通过%cd%引用
----------------------------------------------------------------
# 例：显示当前的完整路径
echo 当前路径是%cd%
```

- .表示当前目录，..表示上一层目录，\表示根目录

- 直接输入盘符，可以切换到对于盘符的根目录

### 列文件名：dir、tree

**dir**

```shell
dir [path]
    [/A[[:]attributes]] [/B] [/C] [/D] [/L] [/N]
    [/O[[:]sortorder]] [/P] [/Q] [/S]
    [/T[[:]timefield]] [/W] [/X] [/4]
----------------------------------------------------------------
    [path]        # 指定要列出的驱动器、目录和/或文件。
----------------------------------------------------------------
    /A            # 显示具有指定属性的文件。
    attributes    D 目录
                  R 只读文件
                  H 隐藏文件
                  A 准备存档的文件
                  S 系统文件
                  - 表示“否”的前缀
----------------------------------------------------------------
    /B            # 使用空格式(没有标题信息或摘要)。
    /C            # 在文件大小中显示千位数分隔符。这是默认值。用/-C来停用分隔符显示。
    /D            # 跟宽式相同，但文件是按栏分类列出的。
    /L            # 用小写。
    /N            # 新的长列表格式，其中文件名在最右边。
----------------------------------------------------------------
    /O            # 用分类顺序列出文件。
    sortorder     N 按名称(字母顺序)
                  S 按大小(从小到大)
                  E 按扩展名(字母顺序)
                  D 按日期/时间(从先到后)
                  G 组目录优先
                  - 颠倒顺序的前缀
----------------------------------------------------------------
    /P            # 在每个信息屏幕后暂停。
    /Q            # 显示文件所有者。
    /S            # 显示指定目录和所有子目录中的文件。
----------------------------------------------------------------
    /T            # 控制显示或用来分类的时间字符域。
    timefield     C 创建时间
                  A 上次访问时间
                  W 上次写入的时间
----------------------------------------------------------------
    /W            # 用宽列表格式。
    /X            # 显示为非 8dot3 文件名产生的短名称。格式是 /N 的格式，
                  # 短名称插在长名称前面。如果没有短名称，在其位置则显示空白。
    /4            # 用四位数字显示年
```
**tree**

```shell
tree [path]       # 以倒立树形式列出目录
----------------------------------------------------------------
    /F            # 显示目录和文件
```

-  `[/A[[:]attributes]]`、`[/O[[:]sortorder]]`、`[/T[[:]timefield]]` 这里可以省略其后的冒号“:”，但之间不能留有空格

### 文件属性：attrib

```shell
# 显示或更改文件属性
attrib [ R | -R] [ A | -A ] [ S | -S] [ H | -H] [path [/S [/D]]]
----------------------------------------------------------------
    -        # 清除属性。
    R        # 只读文件属性。
    A        # 存档文件属性。
    S        # 系统文件属性。
    H        # 隐藏文件属性。
----------------------------------------------------------------
    [path [/S [/D]]]   # 指定要处理的文件属性。
    /S       # 处理当前文件夹及其子文件夹中的匹配文件。
    /D       # 也处理文件夹。/d必需和/s一起使用
```

### 删除：del

```shell
# 删除一个或数个文件
DEL [/P] [/F] [/S] [/Q] [/A[[:]attributes]] <path>
ERASE [/P] [/F] [/S] [/Q] [/A[[:]attributes]] <path>
----------------------------------------------------------------
    /P       # 删除每一个文件之前提示确认。
    /F       # 强制删除只读文件。
    /S       # 从所有子目录删除指定文件。
    /Q       # 安静模式。删除全局通配符时，不要求确认。
----------------------------------------------------------------
    /A       # 根据属性选择要删除的文件。
    attributes    R  只读文件
                  S  系统文件
                  H  隐藏文件
                  A  存档文件
                  -  表示“否”的前缀
```

### 复制：copy、xcopy

**copy**

- copy只能复制文件，不能复制文件夹

```shell
copy <src> [des]
----------------------------------------------------------------
    [des]           # des缺省值为当前目录。
                    # des为文件名时可实现改名
    /Y              # 禁止提示您确认要覆盖现存的目标文件。
```

```shell
# 合并文件
copy { /B | /A } <file1> ＋ [file2] ＋... +[filen] [file_final]
----------------------------------------------------------------
    [file_final]    # 缺省值为file1的文件名
    /B              # 合并方式为Binary
    /A              # 合并方式为ASCII
```

- MP3文件在使用此方法连接后，能实现连续播放。

**xcopy**

```shell
# 复制文件和目录树
xcopy <src> [des] [/A | /M] [/D[:date]] [/P] [/S [/E]] [/V] [/W]
                  [/C] [/I] [/Q] [/F] [/L] [/G] [/H] [/R] [/T] [/U]
                  [/K] [/N] [/O] [/X] [/Y] [/-Y] [/Z]
                  [/EXCLUDE:file1[ file2][ file3]...]
----------------------------------------------------------------
    /S            # 复制非空的目录和子目录。如果省略 /s，xcopy 将在一个目录中工作。
    /E            # 复制所有子目录，包括空目录。
    /H            # 复制具有隐藏和系统文件属性的文件。
    /T            # 只复制子目录结构（即目录树），不复制文件。要复制空目录，必须包含 /e 选项。
    /Y            # 禁止提示您确认要覆盖现存的目标文件。
```

### md、rd、ren、move

**md**

```shell
# 创建目录
md <dir>                           # 创建单个目录
md <dir1> [dir2] [dir3] ...        # 同时创建多个目录
```

- dir中包含有空格或是特殊符号的，一定要用双引号“”括起来

**rd**

```shell
# 删除目录
rmdir [/S] [/Q] <dir>
rd [/S] [/Q] <dir>
----------------------------------------------------------------
    /S        # 同时删除指定目录下的所有子目录和文件
    /Q        # 安静模式，/s删除目录树时不要求确认
```

- 在不加任何参数时，rd命令只能删除空目录

**ren**

```shell
# 重命名
rename [file1] <file2>
ren [file1] <file2>
```

- file2只能为文件名，不能为路径
- 对于隐藏或系统属性的文件，只有把它们的属性去除后，ren命令才会执行

**move**

```shell
# 移动（重命名）文件（目录）
move [/Y | /-Y] <src> <des>
----------------------------------------------------------------
    /Y         # 取消确认改写一个现有目标文件的提示。
    /-Y        # 对确认改写一个现有目标文件发出提示。
```

- MOVE命令可以跨分区移动文件，却不可以跨分区移动文件夹。
- 跨分区移动文件时，如果目标位置存在同名文件，系统会提示：“文件存在”，命令将不会执行。
- 对于隐藏或系统属性的文件，只有把它们的属性去除后，move命令才会执行

### 字符串查找：find、findstr

**find**

```shell
find [/V] [/C] [/N] [/I] [/OFF[LINE]] "string" <file>
----------------------------------------------------------------
    /V        # 显示所有未包含指定字符串的行。
    /C        # 仅显示包含字符串的行数。
    /N        # 显示行号。
    /I        # 搜索字符串时忽略大小写。
    /OFF[LINE]# 不要跳过具有脱机属性集的文件。
    string    # 指定要查找的字符串
    flie      # 指定要查找的文件。
```

**findstr**

```shell
findstr [/B] [/E] [/L] [/R] [/S] [/I] [/X] [/V] [/N] [/M] [/O] [/F:file]
        [/C:string] [/G:file] [/D:dir list] [/A:color attributes] [/OFF[LINE]]
        "string" <file>
----------------------------------------------------------------
    /B        # 在一行的开始配对模式。
    /E        # 在一行的结尾配对模式。
    /L        # 按字使用搜索字符串。
    /R        # 将搜索字符串作为一般表达式使用。
    /S        # 在当前目录和所有子目录中搜索匹配文件。
    /I        # 指定搜索不分大小写。
    /X        # 打印完全匹配的行。
    /V        # 只打印不包含匹配的行。
    /N        # 在匹配的每行前打印行数。
    /M        # 如果文件含有匹配项，只打印其文件名。
    /O        # 在每个匹配行前打印字符偏移量。
    /P        # 忽略有不可打印字符的文件。
    /OFF[LINE]# 不跳过带有脱机属性集的文件。
    /A:attr   # 指定有十六进位数字的颜色属性。请见 "color /?"
    /F:file   # 从指定文件读文件列表 (/代表控制台)。
    /C:string # 使用指定字符串作为文字搜索字符串。
    /G:file   # 从指定的文件获得搜索字符串。 (/代表控制台)。
    /D:dir    # 查找以分号为分隔符的目录列表
    string    # 指定要查找的字符串
    flie      # 指定要查找的文件。
----------------------------------------------------------------
例：
findstr "hello there" x.y'        # 在文件 x.y 中查找"hello"或"there"。
findstr /C:"hello there" x.y'     # 在文件 x.y 中查找"hello there"。
```

- 在使用 findstr "我 你 他" test.txt 的时候，并不能查找到内容
- 但是，加上/i或者/r之后就正确无误了，单个的纯中文字符串没有任何问题。

### 一般表达式

**快速参考**

```shell
.        # 通配符: 任意一个字符
*        # 重复: 前面一个字符或类别出现0或0次以上
^        # 行位置: 行首
$        # 行位置: 行末
[class]  # 字符类别: 任何在字符集中的字符
[^class] # 补字符类别: 任何不在字符集中的字符
[x-y]    # 范围: 在指定范围内的任何字符
\x       # Escape: 元字符 x 的文字用法
\<xyz    # 字位置: 字的开始
xyz\>    # 字位置: 字的结束
```

**\. 和 \***

```shell
findstr . 123.txt 或 findstr "." 123.txt
# 在文件123.txt中查找任意字符，不包括空行。
----------------------------------------------------------------
findstr .* 2.txt 或 findstr ".*" 2.txt
# 在文件123.txt中查找任意字符，包括空行。
----------------------------------------------------------------
findstr ac* 123.txt
# 在文件123.txt中查找出现一个“a”字符串，以及a后面出现过0次或者任意次c的字符行。
```

**\^ 和 \$**

```shell
findstr "^step" 123.txt
# 在文件123.txt中查找行首为step字符串的行。
----------------------------------------------------------------
findstr "step$" 123.txt
# 在文件123.txt中查找行尾为step字符串的行。
```

**\[class\]**

- 字符集里的元素可以是字母和数字和一般的半角字符，如:}{ ,.][等，但双引号"不被识别。
- 不能是汉字， 汉字不被正确解释（汉字不是ASCII码）。
- 如果在字符集内插入通配符和重复符号，即"[.*]"将会把 . 和 * 视为普通字符。

```shell
findstr "[0-9]" 123.txt
# 在文件123.txt中查找数字0－9的任意之一的行。
----------------------------------------------------------------
findstr "[a-zA-Z]" 123.txt
# 在文件123.txt中查找包括任意字母行。
----------------------------------------------------------------
findstr "[abcezy]" 2.txt
# 在文件123.txt中查找包括a b c e z y其中任意一字母的行。
----------------------------------------------------------------
findstr "M[abc][123]Y" 2.txt
#在文件123.txt中查找可以匹配 Ma1Y , Mb1Y, Mc1Y; Ma2Y , Mb2Y, Mc2Y; Ma3Y , Mb3Y, Mc3Y的行。
```

**\[\^class\]**

```shell
findstr "[^0-9]" 123.txt
# 过滤纯数字的行，不能有空格，如2323，6t6t则过滤不了
----------------------------------------------------------------
findstr "[^a-z]" 123.txt
# 过滤纯字母的行，不能有空格，如gdas，6t6t则过滤不了
----------------------------------------------------------------
findstr "[^add]" 123.txt
# 过滤仅含有由a d d三个字母组成的纯字母字符串的行。
```

**\\\<xyz 和 xyz\\\>**

```shell
# xyz可以是英文单词或数字，但不适用于汉字
----------------------------------------------------------------
findstr "\<echo" 123.txt
# 所有含有以echo为前缀的字符串的行，都匹配。
----------------------------------------------------------------
findstr "echo\>" 123.txt
# 所有含有以echo为后缀的字符串的行，都匹配。
----------------------------------------------------------------
findstr "\<end\>" 123.txt
# 精确匹配含单词end的行。
```

**转义字符 \\**

- 把表达式中的特殊字符(元字符)转化为普通字符。
- 如：\\. 、\\* 、\\\\ 、\\[ 、\\]?? 、\\-

```shell
findstr "\.abc" 123.txt
# 在文件123.txt中查找可以匹配“.abc”字符串的行
----------------------------------------------------------------
findstr "1\\" 123.txt 或findstr "1\\\\" 123.txt
# 在文件123.txt中查找可以匹配“1\”字符串的行
```

### 特殊符号

**重定向：> 和 >>**

- \> 重定向符,传递并且覆盖，将运行的结果传递到后面的范围
- 后边可以是文件,也可以是默认的系统控制台

```shell
echo hello120 >1.txt        # 新建立文件1.txt，内容为”hello120”（行尾有一空格,文件后有一空行）
(echo hello120)>1.txt       # 新建立文件1.txt，内容为”hello120”（行尾无空格,但文件后有一空行）
>1.txt echo hello120        # 新建立文件1.txt，内容为”hello120”（行尾无空格,但文件后有一空行）
----------------------------------------------------------------
>1.txt <nul set /p=hello120 # 新建立文件 1.txt，内容为”hello120”（行尾无空格,且文件后也无空行）
>1.txt set /p=hello120<nul  # 新建立文件 1.txt，内容为”hello120”（行尾无空格,且文件后也无空行）
----------------------------------------------------------------
# 如果上面的例子中1.txt原来有内容的话，在使用了>重定向符命令后，将会被新的内容覆盖掉
```

- \>\> 重定向符，将命令的输出结果追加到后面

```shell
echo hello120 >>1.txt
# 如果1.txt不存在，则新建立文件 1.txt，内容为”hello120”
# 如果1.txt存在，则把内容为”hello120”追加到其文末尾
----------------------------------------------------------------
echo hello> 1.txt
echo world>>1.txt
# 1.txt内容如下:
hello
world
```

**管道命令 |** 

- 命令管道符|表示把在它之前的命令或语句的执行结果作为在它之后的命令或语句的处理对象

```shell
tasklist | find /i "qq.exe" && taskkill /f /im qq.exe
# 将tasklist（进程列表）用传递符"|" 传递给find命令，执行查找QQ的进程。
----------------------------------------------------------------
echo Y|rd /s c:\abc
# 通过管道命令|将echo y的结果传给rd /s c:\abc命令，从而达到自动输入y 的目的。
```

**组合命令 &、&&、||**

```shell
<command1> & <command2> [& <command3>...]
# &符号允许同时执行多条命令，当第一个命令执行失败了，也不影响后边的命令执行
----------------------------------------------------------------
<command1> && <command2> [&& <command3>...]
# &&符号允许同时执行多条命令，当碰到执行出错的命令后将不再执行后面的命令
----------------------------------------------------------------
<command1> || <command2> [|| <command3>...]
# ||符号允许同时执行多条命令，当一条命令执行失败后才执行第二条命令
```

- 管道命令的优先级高于重定向命令，重定向命令的优先级高于组合命令。

**转义字符 ^** 

- 如：\^\>、\^\|、\^\|\^\|、\^\^
- 转义字符还可以用作续行符号
- 每行末尾有一个看不见的符号，即回车符，转义字符位于行尾时就让回车符失效了，从而起到了续行的作用。

```shell
# 例：
echo 这是^
一个^
句子
```

**引导变量 %** 

- 当百分号成对出现，并且其间包含非特殊字符时，一般做变量引用处理，比如：%var%、%str%

```shell
# 例
set str=abc
echo 变量 str 的值是： %str%
```

- 对形式参数的引用，单个百分号后面紧跟0～9这10个数字，如%0、%1、%2 。。。

```shell
%0            # 表示批处理文件本身，包括完整的路径和扩展名
%1至%9        # 表示第一个参数至第九个参数
```

- 出现在 set /a 语句中时，表示两数相除取余数它在命令行窗口和批处理文件中的写法略有差异
- 在命令行窗口中，只需要单个的%，在批处理文件中，需要连续两个百分号，写成%%
- 转义符号：如果要显示%本身时，需要在前面用%来转义。

```shell
# 在命令行窗口中，运行 set /a num=4%2 ，则结果将显示0，因为4除以2的余数为0
# 如果保存为批处理文件，则此语句将略有改变：
set /a num=4%%2
echo 4除以2的余数为 %num%
```

**界定符""**

-  在表示带有空格或特殊符号的路径时常要用""来将路径括起来。
- 表示其中的内容是一个完整的字符串。

```shell
# 例：
cd /d cd "d:\program files\^%*abc"
----------------------------------------------------------------
@echo off
set "var=abc 123"
echo %var%
pause
```

## 高级语句

### if语句

```shell
if "str1"=="str2" <command1> [else <command2>]           # 判断两个字符串是否相等
```

```shell
if <value1> equ <value2> <command1> [else <command2>]   # 判断两个数值是否相等
----------------------------------------------------------------
equ        # 等于
gtr        # 大于
geq        # 大于等于
lss        # 小于
leq        # 小于等于
neq        # 不等于
----------------------------------------------------------------
# 批处理中的大于号，小于号，等于号等等都不能用：“>”  “<”  “=” 这些符号，而要用像"gtr"这类的
# 如果要比较的两个元素加了双引号""，那么会被当成是字符的比较。
# 两个元素作比较的流程是：先比较两个元素的首位，如果首位相同，再比较第下一位...
# 例：if "12" lss "4" 语句中，实质是1与4的比较
```

```shell
if exist <file> <command1> [else <command2>]            # 判断驱动器，文件或文件夹是否存在
```

```shell
if defined <var> <command1> [else <command2>]           # 判断变量是否已经定义
----------------------------------------------------------------
# 当变量不存在或是值为空时，变量则为未定义。
# 这里变量为不使用引导符号%的变量名，不能用写为%变量%，否则出错。
```

```shell
if errorlevel <num> <command1> [else <command2>]        # 判断上个命令的返回值
----------------------------------------------------------------
if errorlevel 0 cmmand                                  # 如果返回的错误码值大于或等于0的时候，将执行cmmand操作
if %errorlevel%==0 cmmand                               # 如果返回的错误码值等于0的时候，将执行cmmand操作。
```

- if not 语句
- 对于if语句前面的5种基本语法，都可以加上not参数
- if语句可以嵌套使用

### set命令

**自定义变量**

```shell
set [var=[str]]                  # 设置自定义变量
set /p var=str                   # 交互式界面获取变量值，提示语str
----------------------------------------------------------------
set variable=                    # 将清除变量variable的值，使其变成未定义状态。
set variable=""                  # 此时变量值并不为空，而是等于两个引号，即"" 
```

**替换字符串**

```shell
%PATH:str1=str2%                # 将字符串变量%PATH%中的str1 替换为str2
----------------------------------------------------------------
# 例：
set a= bbs. bathome. cn
echo 替换前的值: "%a%"
set var=%a: =%
echo 替换后的值: "%var%"
# 执行后显示：
# 替换前的值: " bbs. bathome. cn"
# 替换后的值: "bbs.bathome.cn"
```

**截取字符串**

```shell
%a:~[m[,n]]%                    # 截取字符串
# %为变量标识符，a为变量名，冒号用于分隔变量名和说明部分
# m为偏移量（缺省为0），n为截取长度（缺省为全部）
----------------------------------------------------------------
a=bbs.bathome.cn
%a:~1,3%   ---- “bs.”           # 变量a偏离1位，截取3位字符。
%a:~1,-3%  ---- “bs.bathome”    # 变量a偏离1位，截取倒数第3位前的字符。
%a:~-3%    ---- “.cn”           # 变量a偏离-3位，截取倒数的3位字符。
%a:~-3,2%  ---- “.c”            # 变量a偏离-3位，截取倒数后3位的前两2位字符
%a:~3%     ---- “.bathome.cn”   # 变量a偏离3位，截取完后面的字符。
%a:~,3%    ---- “bbs”           # 变量a偏离0位，截取3位字符。
```

**数字表达式**

```shell
set /a <expression>            # /a命令行开关指定等号右边的字符串为数字表达式。
----------------------------------------------------------------
( )                 分组
! ~ -               一元运算符
* / %               算数运算符
-                   算数运算符
<< >>               二进制逻辑移位
&                   二进制按位“与”
^                   二进制按位“异”
|                   二进制按位“或”
= *= /= %= += -=    算数赋值
&= ^= |= <<= >>=    二进制运算赋值
,                   表达式分隔符
----------------------------------------------------------------
# 例:
set /p input=请输入计算表达式：
set /a var=%input%
echo  计算结果：%input%=%var%
```

- DOS计算只能进行整数运算，精确到整数，它是不支持浮点计算的！

- 除法只能精确到整数

- DOS计算只能精确到二进制32位，其中最高位为符号位（0 为正，1 为负），低位31 位为数值。

- 31个1换成十进制为2147483647，所以DOS 计算的有效值范围是-2147483648至2147483647

- 对于逻辑运算符,我们需要把他们用双引号引起来,也可以用转义字符\^

### for语句

```shell
for %%I in <command1> do <command2>
----------------------------------------------------------------
# command1表示的元素可以是一个，也可以是多个
# 每个元素之间用空格键、跳格键、逗号、分号或等号分隔
----------------------------------------------------------------
# 例：
for %%I in (bbs,bathome,cn) do echo %%I    # 结果会分三行显示
for %%i in (*.*) do echo "%%i"             # 显示当前目录所有文件
for %%i in (*.txt) do echo "%%i"           # 显示当前目录所有文本文件
for %%i in (??.txt) do echo "%%i"          # 显示当前目录所有名称为两位字符的文本文件
```

**处理文本文件**

```shell
for /f                                      # 以行为单位处理文本文件
----------------------------------------------------------------
@echo off
for /f %%i in (test.txt) do echo %%i
pause　　
```

**切分字符串**

```shell
delims=                                   # 切分字符串
----------------------------------------------------------------
# 例：
@echo off
for /f "delims=," %%i in (test.txt) do echo %%i
pause　　
----------------------------------------------------------------
"delims=，"                               # 以逗号作为被处理的字符串的分隔符号。
"delims=.，"                              # 以逗号和点号切分
```

- 如果没有指定`delim=`，`for /f `语句默认以空格键或跳格键作为分隔符号

**定点提取**

```shell
tokens=                                  # 定点提取
----------------------------------------------------------------
# tokens= 后面一般跟的是数字，每个数字之间用逗号分隔
# 如tokens=3,5,8；表示提取第3、第5和第8节字符串，这里的“节”，是由delims=划分的
----------------------------------------------------------------
# 例：
@echo off
for /f "delims=， tokens=1,2,3,4,5" %%i in (test.txt) do echo %%i %%j %%k %%l %%m
pause　　
----------------------------------------------------------------
# 如果tokens= 后面指定了多个数字，形式变量遵循字母的排序
# 如果第一个形式变量是%%i，第二个形式变量就是%%j
# 如果第一个形式变量是%%x，第二个形式变量就是%%y
----------------------------------------------------------------
# 提取连续的多节内容，可以只写最小值和最大值，中间用短横连接
# 如 tokens=1,2,3,4,5 可以简写为 tokens=1-5 。
# 例：tokens=1,2-5，tokens=1-3,4,5，tokens=1-4,5...
----------------------------------------------------------------
# *的使用
for /f "delims=， tokens=1,*" %%i in (test.txt) do echo %%i %%j
# 提取前面数字表示的节数之后，后面整体内容被*所表示的一个变量接收
```

**跳行处理**

```shell
skip=n                                   # 跳过n行
----------------------------------------------------------------
@echo off
for /f "skip=2" %%i in (test.txt) do echo %%i
pause　　
# 这段代码将跳过头两行内容，从第3行起显示test.txt中的信息。
```

**忽略指定字符开头的行**

```shell
eol=                                   # 忽略以指定字符打头的行，只能指定一个字符
----------------------------------------------------------------
例：
FOR /F "eol=; tokens=2,3* delims=, " %i in (myfile.txt) do @echo %i %j %k
# 忽略以分号打头的那些行
```

- `for /f `语句默认忽略以分号打头的行

```shell
for /f %%i in (文件名) do (……)
# 当你希望读取文本文件中的内容的话，第一个括号中不用任何符号包裹
for /f %%i in ('命令语句') do (……)
# 当你读取的是命令语句执行结果中的内容的话，第一个括号中的命令语句必须使用单引号包裹
for /f %%i in ("字符串") do (……)　
# 当你要处理的是一个字符串的时候，第一个括号中的内容必须用双引号括起来
----------------------------------------------------------------
# usebackq
# usebackq是一个增强型参数，当使用了这个参数之后，原来的for语句中第一个括号内的写法要做如下变动：
for /f "usebackq" %%i in ("文件名") do (……)
# 如果第一个括号里的对象是文件名的话，要用双引号"括起来。
for /f "usebackq" %%i in (`命令语句`) do (……)
# 如果第一个括号里的对象是一条命令语句的话，原来的单引号'要改为后引号`
for /f "usebackq" %%i in ('字符串') do (……)　
# 如果第一个括号里的对象是字符串的话，原来的双引号"要改为单引号'
```

**for /d 参数**

- 这个参数主要用于目录搜索,不会搜索文件
- 只能搜索指定目录和缺省情况当前目录下的目录名字，不搜索子目录。

```shell
for /d %%var in (set) do <command>            # 查询目录
----------------------------------------------------------------
# 例:
@echo off
for /d %%i in (c:\*) do echo %%i
pause
# 执行后会把C盘根目录下的全部目录名字打印出来,而文件则不显示!
```

**for /r 参数**

```shell
for /r [path] %%var in (set) do <command>    # 遍历搜索当前或指定路径下的文件名字
----------------------------------------------------------------
# path缺省值当前目录
# 如果集仅为一个单点(.)字符，则枚举该目录树
# set如果含有通配符(？或*)，则列举指定目录下（包括子目录）与set相符合的所有文件
# 如果set中为具体文件名，则枚举该目录树，而不管set中的指定文件是否存在。
----------------------------------------------------------------
# 例：
@echo off
for /r c:\ %%i in (boot.ini) do echo %%i
pause
# 执行后，不管boot.ini是否存在都将枚举c盘所有目录
----------------------------------------------------------------
# 为了只列举 boot.ini 存在的目录，我们可改成下面这样
@echo off
for /r c:\ %%i in (boot.ini) do if exist %%i echo %%i
pause
```

- `for /r`不会遍历隐藏文件！

**for /l 参数**

```shell
for /L %%var in (start,step,end) do <command>  # 建立序列
----------------------------------------------------------------
# (start,step,end)表示以增量或者递减形式从开始到结束的一个数字序列。
# 如：(1,1,5)将产生序列1 2 3 4 5，(5,-1,1) 将产生序列5 4 3 2 1
----------------------------------------------------------------
# 例：
@echo off
for /l %%i in (1,1,5) do echo %%i
pause
```

## 延迟环境变量扩展

### 变量扩展

- CMD在读取命令时发现%，会把它当作一个变量处理，找到变量名对应的值换掉这个变量名(如果变量名不存在值,就返回空值)，再执行

- 这个替换值的过程,就叫做变量扩展

- 此时，如果使用if、for等嵌套语句，在括号里面嵌入一些设置变量值的命令,就会出现问题了!

### 延迟环境变量扩展

- 在我们启用了"延迟环境变量扩展"后，当CMD在解释含有嵌套格式的命令时，他会把嵌套的命令一条一条的先执行一次,，然后再进行匹配操作；

- 并且在"延迟环境变量扩展"启用后，CMD会用!号来判断这是不是一个变量；

- 如没启用前变量用%name%这样的格式判断，启用后就用!name!这样的格式判断了
- 延迟环境变量扩展特性在CMD中缺省是关闭的，开启它的方法目前有两个：
  - `cmd /v:{on|off}`，开启或关闭延迟扩展，它会打开一个新的命令行外壳。
  - 在使用`exit`退出这个外壳之前，扩展特性始终有效，常用于命令行环境中
  - `setlocal EnableDelayedExpansion`，它会使环境变量的修改限制到局部空间中。
  - 在`endlocal`之后，扩展特性和之前对环境变量的修改将一同消失，常用于批处理语句中。

```shell
# 例：
@echo off
set mm=girl&echo %mm%
pause
# 执行后显示“ECHO 处于关闭状态”。
----------------------------------------------------------------
@echo off&setlocal EnableDelayedExpansion
set mm=girl&echo !mm!
pause
# 开启了变量延迟，变量扩展（替换）的行为就推迟到echo命令执行时
# 这时echo能感知它前面的命令，从而作出正确的判断并执行
----------------------------------------------------------------
@echo off
set var=abc
for /l %%i in (1 1 5) do (
    set var%%i=%%i
    echo %var%
)
echo %var1% %var2% %var3% %var4% %var5%
pause
# 若没有开启延迟变量，你就没法在复合语句中提取到它，要等复合语句运行完毕后，才能提取到。
----------------------------------------------------------------
@echo off
setlocal EnableDelayedExpansion
set var=abc
for /l %%i in (1 1 10) do (
    set var=%%i
    echo %var%
    echo !var!
)
Pause
# %var% 显示的结果是复合语句之前变量var的值，而 !var! 显示的就是复合语句中即时得到的值。
----------------------------------------------------------------
@echo off
setlocal EnableDelayedExpansion
for /l %%i in (1 1 5) do (
    set var%%i=%%i
)
echo %var1% %var2% %var3% %var4% %var5%
echo !var1! !var2! !var3! !var4! !var5!
pause
# 在开启了延迟变量的情况下，且在复合语句之外，用两种方法都可以表示变量
```

